// Generated by CoffeeScript 1.6.3
(function() {
  var _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.H5 = {
    version: 0.61,
    company: "Hexgis <www.hexgis.com>",
    author: "Helmuth Saatkamp <helmuthdu@gmail.com>",
    isMobile: {
      Android: function() {
        return navigator.userAgent.match(/Android/i);
      },
      BlackBerry: function() {
        return navigator.userAgent.match(/BlackBerry/i);
      },
      iOS: function() {
        return navigator.userAgent.match(/iPhone|iPad|iPod/i);
      },
      Opera: function() {
        return navigator.userAgent.match(/Opera Mini/i);
      },
      Windows: function() {
        return navigator.userAgent.match(/IEMobile/i);
      },
      any: function() {
        return this.Android() || this.BlackBerry() || this.iOS() || this.Opera() || this.Windows();
      }
    }
  };

  H5.Rest = (function() {
    Rest.prototype.options = {
      url: null,
      restService: null,
      table: null,
      fields: null,
      parameters: null,
      order: null,
      limit: null
    };

    Rest.prototype.data = null;

    function Rest(options) {
      if (options.url.substr(options.url.length - 1, 1) !== "/") {
        options.url += "/";
      }
      this.options = $.extend({}, this.options, options);
    }

    Rest.prototype.request = function(service) {
      var query, url;
      if (service) {
        this.options.restService = "ws_geo_" + service + ".php";
      } else {
        this.options.restService = "ws_geo_attributequery.php";
      }
      url = this.options.url + "v1/" + this.options.restService;
      query = {};
      if (this.options.table) {
        query.table = this.options.table;
      }
      if (this.options.parameters) {
        query.parameters = this.options.parameters;
      }
      if (this.options.fields) {
        query.fields = this.options.fields;
      }
      if (this.options.order) {
        query.order = this.options.order;
      }
      if (this.options.limit) {
        query.limit = this.options.limit;
      }
      this._get(url, query);
      return this.data;
    };

    Rest.prototype.getURLParam = function(param) {
      var compareKeyValuePair, comparisonResult, i, params, search;
      search = window.location.search.substring(1);
      compareKeyValuePair = function(pair) {
        var decodedKey, decodedValue, key_value;
        key_value = pair.split("=");
        decodedKey = decodeURIComponent(key_value[0]);
        decodedValue = decodeURIComponent(key_value[1]);
        if (decodedKey === param) {
          return decodedValue;
        }
        return null;
      };
      comparisonResult = null;
      if (search.indexOf("&") > -1) {
        params = search.split("&");
        i = 0;
        while (i < params.length) {
          comparisonResult = compareKeyValuePair(params[i]);
          if (comparisonResult !== null) {
            break;
          }
          i++;
        }
      } else {
        comparisonResult = compareKeyValuePair(search);
      }
      return comparisonResult;
    };

    Rest.prototype._get = function(url, query) {
      var _this = this;
      return $.ajax({
        type: "GET",
        async: false,
        url: url,
        data: query,
        dataType: "jsonp",
        success: function(data) {
          return _this._done(data);
        },
        error: function(error, status, desc) {
          return console.log(status, desc);
        }
      });
    };

    Rest.prototype._done = function(data) {
      return this.data = data;
    };

    return Rest;

  })();

  google.load("visualization", "1", {
    packages: ["corechart"]
  });

  google.load("visualization", "1", {
    packages: ["gauge"]
  });

  google.load("visualization", "1", {
    packages: ["table"]
  });

  H5.Data = {};

  H5.DB = {
    addDB: function(opt) {
      this[opt.name] = {};
      this[opt.name].table = opt.table;
      return this[opt.name].data = null;
    }
  };

  H5.Charts = {};

  H5.Charts.Container = (function() {
    Container.prototype.options = {
      type: null,
      container: null,
      period: 1,
      started: false,
      title: "",
      defaultClass: "",
      selects: void 0,
      resizing: 0,
      buttons: {
        minusplus: false,
        arrows: false,
        table: false,
        "export": false,
        minimize: false,
        maximize: false,
        close: false
      }
    };

    function Container(options) {
      this.options = $.extend({}, this.options, options);
      this._createContainer();
    }

    Container.prototype.changeTitle = function(title) {
      var pipeline;
      $(this._chartTitle).html(title);
      if (this.options.buttons.arrows || this.options.buttons.minusplus || (this.options.selects != null)) {
        pipeline = "<span class=\"break\"></span>";
        return $(this._chartTitle).prepend(pipeline);
      }
    };

    Container.prototype._createContainer = function() {
      var addBtn, addIcon, chartContent, chartHeader, chartTable, chartTitle, closeBtn, closeIcon, delBtn, delIcon, exportBtn, exportIcon, formBtn, leftBtn, leftCtrl, leftIcon, maxBtn, maxIcon, minBtn, minIcon, pipeline, rightBtn, rightCtrl, rightIcon, tableBtn, tableIcon,
        _this = this;
      this._container = document.getElementById(this.options.container);
      chartHeader = document.createElement("div");
      chartHeader.className = "chart-header";
      this._chartHeader = chartHeader;
      chartTitle = document.createElement("h2");
      chartTitle.innerHTML = this.options.title;
      this._chartTitle = chartTitle;
      leftCtrl = document.createElement("div");
      leftCtrl.className = "btn-group chart-icon btn-left";
      this._leftCtrl = leftCtrl;
      rightCtrl = document.createElement("div");
      rightCtrl.className = "btn-group chart-icon btn-right";
      this._rightCtrl = rightCtrl;
      chartContent = document.createElement("div");
      chartContent.id = "chart-" + this.options.container;
      chartContent.className = "chart-content";
      this._chartContent = chartContent;
      $(this._chartHeader).append(this._leftCtrl, this._chartTitle, this._rightCtrl);
      $(this._container).append(this._chartHeader, this._chartContent);
      pipeline = "<span class=\"break\"></span>";
      if (this.options.buttons.minusplus) {
        $(this._chartTitle).prepend(pipeline);
        delBtn = document.createElement("button");
        delBtn.id = this.options.container + "-btn-minus";
        delBtn.className = "btn";
        this._delBtn = delBtn;
        delIcon = document.createElement("i");
        delIcon.className = "icon-minus";
        this._delIcon = delIcon;
        $(this._delBtn).append(this._delIcon);
        addBtn = document.createElement("button");
        addBtn.id = this.options.container + "-btn-plus";
        addBtn.className = "btn";
        this._addBtn = addBtn;
        addIcon = document.createElement("i");
        addIcon.className = "icon-plus";
        this._addIcon = addIcon;
        $(this._addBtn).append(this._addIcon);
        $(this._leftCtrl).append(this._delBtn, this._addBtn);
      } else if (this.options.buttons.arrows) {
        $(this._chartTitle).prepend(pipeline);
        leftBtn = document.createElement("button");
        leftBtn.id = this.options.container + "-btn-left";
        leftBtn.className = "btn";
        this._leftBtn = leftBtn;
        leftIcon = document.createElement("i");
        leftIcon.className = "icon-arrow-left";
        this._leftIcon = leftIcon;
        $(this._leftBtn).append(this._leftIcon);
        rightBtn = document.createElement("button");
        rightBtn.id = this.options.container + "-btn-right";
        rightBtn.className = "btn";
        this._rightBtn = rightBtn;
        rightIcon = document.createElement("i");
        rightIcon.className = "icon-arrow-right";
        this._rightIcon = rightIcon;
        $(this._rightBtn).append(this._rightIcon);
        $(this._leftCtrl).append(this._leftBtn, this._rightBtn);
      } else if (this.options.selects != null) {
        $(this._chartTitle).prepend(pipeline);
        formBtn = document.createElement("form");
        formBtn.name = "form-" + this.options.container;
        formBtn.className = "form-inline";
        this._formBtn = formBtn;
        $.each(this.options.selects, function(name, options) {
          var select;
          select = "<select id=\"" + name + "Slct\" class=\"input-mini\" name=\"" + name + "\">";
          $.each(options, function(value, key) {
            return select += "<option value=" + value + ">" + key + "</option>";
          });
          select += "</select>";
          return $(_this._formBtn).append(select);
        });
        $(this._leftCtrl).append(this._formBtn);
        $(this._leftCtrl).removeClass("btn-group");
        $.each(this.options.selects, function(name, data) {
          _this["_" + name + "Slct"] = document["form-" + _this.options.container][name];
          return _this._enableSelect("#" + name + "Slct");
        });
      }
      if (this.options.buttons.table) {
        tableBtn = document.createElement("button");
        tableBtn.id = this.options.container + "-btn-table";
        tableBtn.className = "btn";
        this._tableBtn = tableBtn;
        tableIcon = document.createElement("i");
        tableIcon.className = "icon-table";
        this._tableIcon = tableIcon;
        $(this._tableBtn).append(this._tableIcon);
        $(this._rightCtrl).append(this._tableBtn);
        chartTable = document.createElement("div");
        chartTable.id = "table-" + this.options.container;
        chartTable.className = "chart-table";
        this._chartTable = chartTable;
        $(this._container).append(this._chartTable);
        this._enableTable();
      }
      if (this.options.buttons["export"]) {
        exportBtn = document.createElement("button");
        exportBtn.id = this.options.container + "-btn-export";
        exportBtn.className = "btn";
        this._exportBtn = exportBtn;
        exportIcon = document.createElement("i");
        exportIcon.className = "icon-download-alt";
        this._exportIcon = exportIcon;
        $(this._exportBtn).append(this._exportIcon);
        $(this._rightCtrl).append(this._exportBtn);
        this._enableExport();
      }
      if (this.options.buttons.minimize) {
        minBtn = document.createElement("button");
        minBtn.id = this.options.container + "-btn-minimize";
        minBtn.className = "btn";
        this._minBtn = minBtn;
        minIcon = document.createElement("i");
        minIcon.className = "icon-chevron-up";
        this._minIcon = minIcon;
        $(this._minBtn).append(this._minIcon);
        $(this._rightCtrl).append(this._minBtn);
        this._enableMinimize();
      }
      if (this.options.buttons.maximize) {
        maxBtn = document.createElement("button");
        maxBtn.id = this.options.container + "-btn-maximize";
        maxBtn.className = "btn";
        this._maxBtn = maxBtn;
        maxIcon = document.createElement("i");
        maxIcon.className = "icon-resize-full";
        this._maxIcon = maxIcon;
        $(this._maxBtn).append(this._maxIcon);
        $(this._rightCtrl).append(this._maxBtn);
        this._enableMaximize();
      }
      if (this.options.buttons.close) {
        closeBtn = document.createElement("button");
        closeBtn.id = this.options.container + "-btn-close";
        closeBtn.className = "btn";
        this._closeBtn = closeBtn;
        closeIcon = document.createElement("i");
        closeIcon.className = "icon-remove";
        this._closeIcon = closeIcon;
        $(this._closeBtn).append(this._closeIcon);
        $(this._rightCtrl).append(this._closeBtn);
        return this._enableClose();
      }
    };

    Container.prototype._enableMinimize = function() {
      var _this = this;
      return $(this._minBtn).on("click", function(event) {
        event.preventDefault();
        if ($(_this._chartContent).is(":visible")) {
          _this._minIcon.className = "icon-chevron-down";
          if (_this.options.buttons.minusplus) {
            $(_this._addBtn).prop("disabled", true);
            $(_this._delBtn).prop("disabled", true);
          } else if (_this.options.buttons.arrows) {
            $(_this._leftBtn).prop("disabled", true);
            $(_this._rightBtn).prop("disabled", true);
          }
        } else {
          _this._minIcon.className = "icon-chevron-up";
          if (_this.options.buttons.minusplus) {
            $(_this._addBtn).prop("disabled", false);
            $(_this._delBtn).prop("disabled", false);
          } else if (_this.options.buttons.arrows) {
            $(_this._leftBtn).prop("disabled", false);
            $(_this._rightBtn).prop("disabled", false);
          }
        }
        if ($(_this._chartTable).is(":visible")) {
          $(_this._chartTable).slideToggle("fast", "linear");
        }
        return $(_this._chartContent).slideToggle("fast", "linear");
      });
    };

    Container.prototype._enableMaximize = function() {
      var _this = this;
      return $(this._maxBtn).on("click", function(event) {
        event.preventDefault();
        if (_this._maxIcon.className === "icon-resize-full") {
          _this.defaultClass = _this._container.className;
          $(_this._minBtn).prop("disabled", true);
          $(_this._closeBtn).prop("disabled", true);
          _this._maxIcon.className = "icon-resize-small";
          $("#navbar").hide();
        } else {
          $(_this._minBtn).prop("disabled", false);
          $(_this._closeBtn).prop("disabled", false);
          _this._maxIcon.className = "icon-resize-full";
          $("#navbar").show();
        }
        if ($(_this._chartTable).is(":visible")) {
          $(_this._chartTable).slideToggle("fast", "linear");
        }
        $(_this._chartTable).toggleClass("table-overlay");
        $(_this._container).toggleClass(_this.defaultClass);
        $(_this._container).toggleClass("chart-overlay");
        $("body").toggleClass("body-overlay");
        $(_this._chartContent).toggleClass("chart-content-overlay");
        $(_this._chartTable).toggleClass("table-content-overlay");
        $(_this._chartContent).hide();
        $(_this._chartContent).fadeToggle(500, "linear");
        return _this.drawChart();
      });
    };

    Container.prototype._enableClose = function() {
      var _this = this;
      return $(this._closeBtn).on("click", function(event) {
        event.preventDefault();
        return $(_this._container).hide("slide", "linear", 600);
      });
    };

    Container.prototype._enableSelect = function(select) {
      var _this = this;
      return $(select).on("change", function(event) {
        return _this.drawChart();
      });
    };

    return Container;

  })();

  H5.Charts.GoogleCharts = (function(_super) {
    __extends(GoogleCharts, _super);

    function GoogleCharts() {
      _ref = GoogleCharts.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    GoogleCharts.prototype.createDataTable = function() {
      return this.data = new google.visualization.DataTable();
    };

    GoogleCharts.prototype.createChart = function() {
      if (!this.options.started) {
        if (this.options.type === "Gauge") {
          this.chart = new google.visualization.Gauge(this._chartContent);
        } else {
          this.chart = new google.visualization[this.options.type + "Chart"](this._chartContent);
        }
        this.options.started = true;
        return this._detectScreenChanges();
      }
    };

    GoogleCharts.prototype._detectScreenChanges = function() {
      var orientationEvent, supportsOrientationChange,
        _this = this;
      supportsOrientationChange = "onorientationchange" in window;
      orientationEvent = (supportsOrientationChange ? "orientationchange" : "resize");
      return window.addEventListener(orientationEvent, (function() {
        return _this.drawChart();
      }), false);
    };

    GoogleCharts.prototype._enableTable = function() {
      var _this = this;
      return $(this._tableBtn).on("click", function(event) {
        var visualization;
        event.preventDefault();
        if ($(_this._chartContent).is(":hidden")) {
          _this._minIcon.className = "icon-chevron-up";
          $(_this._chartContent).fadeToggle('fast', 'linear');
        }
        $(_this._chartTable).fadeToggle('fast', 'linear');
        if ($(_this._chartTable).is(":visible")) {
          visualization = new google.visualization.Table(_this._chartTable);
          return visualization.draw(_this.data, null);
        }
      });
    };

    GoogleCharts.prototype._enableExport = function() {
      var generateCSV,
        _this = this;
      generateCSV = function() {
        var col, line, row, str, title, value, _i, _j, _k, _ref1, _ref2, _ref3;
        str = "";
        line = "";
        for (col = _i = 0, _ref1 = _this.data.getNumberOfColumns(); 0 <= _ref1 ? _i < _ref1 : _i > _ref1; col = 0 <= _ref1 ? ++_i : --_i) {
          title = _this.data.getColumnLabel(col);
          line += "\"" + title + "\",";
        }
        str += line + "\r\n";
        for (row = _j = 0, _ref2 = _this.data.getNumberOfRows(); 0 <= _ref2 ? _j < _ref2 : _j > _ref2; row = 0 <= _ref2 ? ++_j : --_j) {
          line = "";
          for (col = _k = 0, _ref3 = _this.data.getNumberOfColumns(); 0 <= _ref3 ? _k < _ref3 : _k > _ref3; col = 0 <= _ref3 ? ++_k : --_k) {
            value = _this.data.getFormattedValue(row, col);
            line += "\"" + value + "\",";
          }
          str += line + "\r\n";
        }
        return str;
      };
      return $(this._exportBtn).click(function() {
        var csv;
        csv = generateCSV();
        return window.open("data:text/csv;charset=utf-8," + escape(csv));
      });
    };

    return GoogleCharts;

  })(H5.Charts.Container);

  H5.Charts.SmallContainer = (function() {
    SmallContainer.prototype.options = {
      type: null,
      container: null,
      title: "",
      popover: false
    };

    function SmallContainer(options) {
      this.options = $.extend({}, this.options, options);
      this._createContainer();
    }

    SmallContainer.prototype._createContainer = function() {
      var leftCtrl, rightCtrl;
      this._container = document.getElementById(this.options.container);
      leftCtrl = document.createElement("div");
      leftCtrl.className = "left";
      this._leftCtrl = leftCtrl;
      rightCtrl = document.createElement("div");
      rightCtrl.className = "right";
      this._rightCtrl = rightCtrl;
      $(this._container).append(this._leftCtrl, this._rightCtrl);
      if (this.options.popover) {
        $(this._container).addClass("popover-" + this.options.container);
        return this._createPopover();
      }
    };

    SmallContainer.prototype._createPopover = function() {
      var html, placement, trigger;
      placement = "bottom";
      trigger = "hover";
      html = true;
      return $(".popover-" + this.options.container).popover({
        placement: placement,
        delay: {
          show: 700,
          hide: 300
        },
        content: "<span>" + this.options.popover + "</span>",
        trigger: trigger,
        html: html
      });
    };

    return SmallContainer;

  })();

  H5.Charts.Knobs = (function(_super) {
    __extends(Knobs, _super);

    function Knobs() {
      _ref1 = Knobs.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    Knobs.prototype.updateInfo = function(value) {
      $(this._rightCtrl).html("<strong>" + value + "%</strong><br/> " + this.options.title);
      return this._updateChart(parseFloat(value));
    };

    Knobs.prototype._createContainer = function() {
      var dial;
      Knobs.__super__._createContainer.apply(this, arguments);
      dial = document.createElement("input");
      dial.type = "text";
      dial.className = "dial";
      this._dial = dial;
      $(this._leftCtrl).append(this._dial);
      return this._createChart();
    };

    Knobs.prototype._createChart = function() {
      $(this._dial).knob({
        min: -100,
        max: 100,
        bgColor: "#DEDEDE",
        fgColor: "#DEDEDE",
        angleOffset: -125,
        angleArc: 250,
        readOnly: true,
        width: 58,
        height: 58,
        thickness: 0.5,
        displayInput: false,
        color: "alert",
        draw: function() {
          var color, value, _max, _min;
          value = this.val();
          _min = this.o.min;
          _max = this.o.max;
          if (this.color === "coldtohot") {
            if ((_min <= value && value <= _min * 0.3)) {
              color = pusher.color("#67C2EF");
            } else if ((_min * 0.3 < value && value <= _max * 0.3)) {
              color = pusher.color("#CBE968");
            } else if ((_max * 0.3 < value && value <= _max * 0.7)) {
              color = pusher.color("#FABB3D");
            } else if ((_max * 0.7 < value && value <= _max * 0.9)) {
              color = pusher.color("#FA603D");
            } else {
              color = pusher.color("#FF5454");
            }
          } else {
            if (value <= 0) {
              color = pusher.color("#D0FC3F");
            } else if ((0 < value && value <= _max * 0.6)) {
              color = pusher.color("#FCAC0A");
            } else {
              color = pusher.color("#FC2121");
            }
          }
          return this.o.fgColor = color.html();
        }
      });
      return $(this._dial).val(0).trigger("change");
    };

    Knobs.prototype._updateChart = function(total) {
      var dial;
      dial = $(this._leftCtrl).find('.dial');
      if (!H5.isMobile.any()) {
        return $({
          value: dial.val()
        }).animate({
          value: total
        }, {
          duration: 2000,
          easing: "easeOutSine",
          step: function() {
            return dial.val(Math.floor(this.value)).trigger("change");
          }
        });
      } else {
        return dial.val(Math.floor(total)).trigger("change");
      }
    };

    return Knobs;

  })(H5.Charts.SmallContainer);

  H5.Charts.Sparks = (function(_super) {
    __extends(Sparks, _super);

    function Sparks() {
      _ref2 = Sparks.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    Sparks.prototype.updateInfo = function(data, value) {
      $(this._rightCtrl).html("<strong>" + value + "</strong><br /> " + this.options.title);
      return this._updateChart(data);
    };

    Sparks.prototype._createContainer = function() {
      var spark;
      Sparks.__super__._createContainer.apply(this, arguments);
      spark = document.createElement("div");
      spark.className = "minichart";
      this._spark = spark;
      return $(this._leftCtrl).append(this._spark);
    };

    Sparks.prototype._updateChart = function(data) {
      return $(this._spark).sparkline(data, {
        width: 58,
        height: 62,
        lineColor: "#2FABE9",
        fillColor: "#67C2EF",
        spotColor: "#CBE968",
        maxSpotColor: "#FF5454",
        minSpotColor: "#67C2EF",
        spotRadius: 1.5,
        lineWidth: 1
      });
    };

    return Sparks;

  })(H5.Charts.SmallContainer);

  H5.Map = {
    base: null,
    layer: {},
    layerList: null
  };

  H5.Leaflet = {};

  H5.Leaflet.Layer = L.Class.extend({
    options: {
      scaleRange: null,
      map: null,
      cluster: false,
      uniqueField: null,
      visibleAtScale: true,
      dynamic: false,
      autoUpdate: false,
      autoUpdateInterval: null,
      popupTemplate: null,
      popupOptions: {},
      singlePopup: false,
      symbology: null,
      showAll: false
    },
    initialize: function(options) {
      return L.Util.setOptions(this, options);
    },
    setMap: function(map) {
      var sr, z;
      if (map && this.options.map) {
        return;
      }
      if (map) {
        this.options.map = map;
        if (this.options.scaleRange && this.options.scaleRange instanceof Array && this.options.scaleRange.length === 2) {
          z = this.options.map.getZoom();
          sr = this.options.scaleRange;
          this.options.visibleAtScale = z >= sr[0] && z <= sr[1];
        }
        return this._show();
      } else if (this.options.map) {
        this._hide();
        return this.options.map = map;
      }
    },
    getMap: function() {
      return this.options.map;
    },
    setOptions: function(options) {
      return L.Util.setOptions(this, options);
    },
    redraw: function() {
      return this._getFeatures();
    },
    _show: function() {
      var _this = this;
      this._addIdleListener();
      if (this.options.scaleRange && this.options.scaleRange instanceof Array && this.options.scaleRange.length === 2) {
        this._addZoomChangeListener();
      }
      if (this.options.visibleAtScale) {
        if (this.options.autoUpdate && this.options.autoUpdateInterval) {
          this._autoUpdateInterval = setInterval(function() {
            return _this._getFeatures();
          }, this.options.autoUpdateInterval);
        }
        return this.options.map.fire("moveend").fire("zoomend");
      }
    },
    _hide: function() {
      if (this._idleListener) {
        this.options.map.off("moveend", this._idleListener);
      }
      if (this._zoomChangeListener) {
        this.options.map.off("zoomend", this._zoomChangeListener);
      }
      if (this._autoUpdateInterval) {
        clearInterval(this._autoUpdateInterval);
      }
      this._clearFeatures();
      this._lastQueriedBounds = null;
      if (this._gotAll) {
        return this._gotAll = false;
      }
    },
    _hideVectors: function() {
      var i, j, _i, _ref3, _results;
      _results = [];
      for (i = _i = 0, _ref3 = this._vectors.length; 0 <= _ref3 ? _i < _ref3 : _i > _ref3; i = 0 <= _ref3 ? ++_i : --_i) {
        if (this._vectors[i].vector) {
          this.options.map.removeLayer(this._vectors[i].vector);
          if (this._vectors[i].popup) {
            this.options.map.removeLayer(this._vectors[i].popup);
          } else if (this.popup && this.popup.associatedFeature && this.popup.associatedFeature === this._vectors[i]) {
            this.options.map.removeLayer(this.popup);
            this.popup = null;
          }
        }
        if (this._vectors[i].vectors && this._vectors[i].vectors.length) {
          _results.push((function() {
            var _j, _ref4, _results1;
            _results1 = [];
            for (j = _j = 0, _ref4 = this._vectors[i].vectors.length; 0 <= _ref4 ? _j < _ref4 : _j > _ref4; j = 0 <= _ref4 ? ++_j : --_j) {
              this.options.map.removeLayer(this._vectors[i].vectors[j]);
              if (this._vectors[i].vectors[j].popup) {
                _results1.push(this.options.map.removeLayer(this._vectors[i].vectors[j].popup));
              } else if (this.popup && this.popup.associatedFeature && this.popup.associatedFeature === this._vectors[i]) {
                this.options.map.removeLayer(this.popup);
                _results1.push(this.popup = null);
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          }).call(this));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    _showVectors: function() {
      var i, j, _i, _ref3, _results;
      _results = [];
      for (i = _i = 0, _ref3 = this._vectors.length; 0 <= _ref3 ? _i < _ref3 : _i > _ref3; i = 0 <= _ref3 ? ++_i : --_i) {
        if (this._vectors[i].vector) {
          this.options.map.addLayer(this._vectors[i].vector);
        }
        if (this._vectors[i].vectors && this._vectors[i].vectors.length) {
          _results.push((function() {
            var _j, _ref4, _results1;
            _results1 = [];
            for (j = _j = 0, _ref4 = this._vectors[i].vectors.length; 0 <= _ref4 ? _j < _ref4 : _j > _ref4; j = 0 <= _ref4 ? ++_j : --_j) {
              _results1.push(this.options.map.addLayer(this._vectors[i].vectors[j]));
            }
            return _results1;
          }).call(this));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    _clearFeatures: function() {
      this._hideVectors();
      return this._vectors = [];
    },
    _addZoomChangeListener: function() {
      this._zoomChangeListener = this._zoomChangeListenerTemplate();
      return this.options.map.on("zoo@d", this._zoomChangeListener, this);
    },
    _zoomChangeListenerTemplate: function() {
      var _this = this;
      return function() {
        return _this._checkLayerVisibility();
      };
    },
    _idleListenerTemplate: function() {
      var _this = this;
      return function() {
        if (_this.options.visibleAtScale) {
          if (_this.options.showAll) {
            if (!_this._gotAll) {
              _this._getFeatures();
              return _this._gotAll = true;
            }
          } else {
            return _this._getFeatures();
          }
        }
      };
    },
    _addIdleListener: function() {
      this._idleListener = this._idleListenerTemplate();
      return this.options.map.on("moveend", this._idleListener, this);
    },
    _checkLayerVisibility: function() {
      var me, sr, visibilityBefore, z;
      visibilityBefore = this.options.visibleAtScale;
      z = this.options.map.getZoom();
      sr = this.options.scaleRange;
      this.options.visibleAtScale = z >= sr[0] && z <= sr[1];
      if (visibilityBefore !== this.options.visibleAtScale) {
        this[(this.options.visibleAtScale ? "_showVectors" : "_hideVectors")]();
      }
      if (visibilityBefore && !this.options.visibleAtScale && this._autoUpdateInterval) {
        return clearInterval(this._autoUpdateInterval);
      } else if (!visibilityBefore && this.options.autoUpdate && this.options.autoUpdateInterval) {
        me = this;
        return this._autoUpdateInterval = setInterval(function() {
          return me._getFeatures();
        }, this.options.autoUpdateInterval);
      }
    },
    _setPopupContent: function(feature) {
      var atts, popupContent, previousContent, prop, re;
      previousContent = feature.popupContent;
      atts = feature.properties;
      popupContent = void 0;
      if (typeof this.options.popupTemplate === "string") {
        popupContent = this.options.popupTemplate;
        for (prop in atts) {
          re = new RegExp("{" + prop + "}", "g");
          popupContent = popupContent.replace(re, atts[prop]);
        }
      } else if (typeof this.options.popupTemplate === "function") {
        popupContent = this.options.popupTemplate(atts);
      } else {
        return;
      }
      feature.popupContent = popupContent;
      if (feature.popup) {
        if (feature.popupContent !== previousContent) {
          return feature.popup.setContent(feature.popupContent);
        }
      } else if (this.popup && this.popup.associatedFeature === feature) {
        if (feature.popupContent !== previousContent) {
          return this.popup.setContent(feature.popupContent);
        }
      }
    },
    _showPopup: function(feature, event) {
      var isLineOrPolygon, ownsPopup;
      isLineOrPolygon = event.latlng;
      if (!isLineOrPolygon) {
        L.Util.extend(this.options.popupOptions, {
          offset: event.target.options.icon.options.popupAnchor
        });
      }
      ownsPopup = void 0;
      if (!this.options.singlePopup) {
        feature.popup = new L.Popup(this.options.popupOptions, feature.vector);
        ownsPopup = feature;
      } else {
        if (this.popup) {
          this.options.map.removeLayer(this.popup);
          this.popup = null;
        }
        this.popup = new L.Popup(this.options.popupOptions, feature.vector);
        this.popup.associatedFeature = feature;
        ownsPopup = this;
      }
      ownsPopup.popup.setLatLng((isLineOrPolygon ? event.latlng : event.target.getLatLng()));
      ownsPopup.popup.setContent(feature.popupContent);
      return this.options.map.addLayer(ownsPopup.popup);
    },
    _fireClickEvent: function(feature, event) {
      return this.options.clickEvent(feature, event);
    },
    _getFeatureVectorOptions: function(feature) {
      var att, atts, i, key, prop, re, vectorStyle, _i, _j, _ref3, _ref4;
      vectorStyle = {};
      atts = feature.properties;
      if (this.options.symbology) {
        switch (this.options.symbology.type) {
          case "single":
            for (key in this.options.symbology.vectorStyle) {
              vectorStyle[key] = this.options.symbology.vectorStyle[key];
              if (vectorStyle.title) {
                for (prop in atts) {
                  re = new RegExp("{" + prop + "}", "g");
                  vectorStyle.title = vectorStyle.title.replace(re, atts[prop]);
                }
              }
            }
            break;
          case "unique":
            att = this.options.symbology.property;
            for (i = _i = 0, _ref3 = this.options.symbology.values.length; 0 <= _ref3 ? _i < _ref3 : _i > _ref3; i = 0 <= _ref3 ? ++_i : --_i) {
              if (atts[att] === this.options.symbology.values[i].value) {
                for (key in this.options.symbology.values[i].vectorStyle) {
                  vectorStyle[key] = this.options.symbology.values[i].vectorStyle[key];
                  if (vectorStyle.title) {
                    for (prop in atts) {
                      re = new RegExp("{" + prop + "}", "g");
                      vectorStyle.title = vectorStyle.title.replace(re, atts[prop]);
                    }
                  }
                }
              }
            }
            break;
          case "range":
            att = this.options.symbology.property;
            for (i = _j = 0, _ref4 = this.options.symbology.ranges.length; 0 <= _ref4 ? _j < _ref4 : _j > _ref4; i = 0 <= _ref4 ? ++_j : --_j) {
              if (atts[att] >= this.options.symbology.ranges[i].range[0] && atts[att] <= this.options.symbology.ranges[i].range[1]) {
                for (key in this.options.symbology.ranges[i].vectorStyle) {
                  vectorStyle[key] = this.options.symbology.ranges[i].vectorStyle[key];
                  if (vectorStyle.title) {
                    for (prop in atts) {
                      re = new RegExp("{" + prop + "}", "g");
                      vectorStyle.title = vectorStyle.title.replace(re, atts[prop]);
                    }
                  }
                }
              }
            }
        }
      }
      return vectorStyle;
    },
    _getPropertiesChanged: function(oldAtts, newAtts) {
      var changed, key;
      changed = false;
      for (key in oldAtts) {
        if (oldAtts[key] !== newAtts[key]) {
          changed = true;
        }
      }
      return changed;
    },
    _getPropertyChanged: function(oldAtts, newAtts, property) {
      return oldAtts[property] !== newAtts[property];
    },
    _getGeometryChanged: function(oldGeom, newGeom) {
      var changed;
      changed = false;
      if (!oldGeom.coordinates[0] === newGeom.coordinates[0] && oldGeom.coordinates[1] === newGeom.coordinates[1]) {
        changed = true;
      }
      return changed;
    },
    _makeJsonpRequest: function(url) {
      var head, script;
      head = document.getElementsByTagName("head")[0];
      script = document.createElement("script");
      script.type = "text/javascript";
      script.src = url;
      return head.appendChild(script);
    },
    _processRequest: function(json) {
      var data, i, prop, _i, _ref3;
      data = {};
      data.features = [];
      data.total = json.length;
      data.type = "FeatureCollection";
      for (i = _i = 0, _ref3 = json.length; 0 <= _ref3 ? _i < _ref3 : _i > _ref3; i = 0 <= _ref3 ? ++_i : --_i) {
        data.features[i] = {};
        data.features[i].type = "Feature";
        data.features[i].properties = {};
        for (prop in json[i]) {
          if (prop === "geojson") {
            data.features[i].geometry = JSON.parse(json[i].geojson);
          } else {
            if (prop !== "properties") {
              data.features[i].properties[prop] = json[i][prop];
            }
          }
        }
      }
      json = null;
      return this._processFeatures(data);
    },
    _processFeatures: function(data) {
      var bounds, feature, geometry, geometryOptions, i, j, k, markers, me, onMap, propertiesChanged, symbologyPropertyChanged, vector_or_vectors, _i, _j, _k, _l, _m, _ref3, _ref4, _ref5, _ref6, _ref7, _results;
      if (!this.options.map) {
        return;
      }
      bounds = this.options.map.getBounds();
      if (this._lastQueriedBounds && this._lastQueriedBounds.equals(bounds) && !this.options.autoUpdate) {
        return;
      }
      if (this.options.cluster) {
        markers = new L.MarkerClusterGroup();
      }
      this._lastQueriedBounds = bounds;
      if (data && data.features && data.features.length) {
        _results = [];
        for (i = _i = 0, _ref3 = data.features.length; 0 <= _ref3 ? _i < _ref3 : _i > _ref3; i = 0 <= _ref3 ? ++_i : --_i) {
          onMap = false;
          if (this.options.uniqueField) {
            for (j = _j = 0, _ref4 = this._vectors.length; 0 <= _ref4 ? _j < _ref4 : _j > _ref4; j = 0 <= _ref4 ? ++_j : --_j) {
              if (data.features[i].properties[this.options.uniqueField] === this._vectors[j].properties[this.options.uniqueField]) {
                onMap = true;
                if (this.options.dynamic) {
                  if (this._getGeometryChanged(this._vectors[j].geometry, data.features[i].geometry)) {
                    if (!isNaN(data.features[i].geometry.coordinates[0]) && !isNaN(data.features[i].geometry.coordinates[1])) {
                      this._vectors[j].geometry = data.features[i].geometry;
                      this._vectors[j].vector.setLatLng(new L.LatLng(this._vectors[j].geometry.coordinates[1], this._vectors[j].geometry.coordinates[0]));
                    }
                  }
                  propertiesChanged = this._getPropertiesChanged(this._vectors[j].properties, data.features[i].properties);
                  if (propertiesChanged) {
                    symbologyPropertyChanged = this._getPropertyChanged(this._vectors[j].properties, data.features[i].properties, this.options.symbology.property);
                    this._vectors[j].properties = data.features[i].properties;
                    if (this.options.popupTemplate) {
                      this._setPopupContent(this._vectors[j]);
                    }
                    if (this.options.symbology && this.options.symbology.type !== "single" && symbologyPropertyChanged) {
                      if (this._vectors[j].vectors) {
                        for (k = _k = 0, _ref5 = this._vectors[j].vectors.length; 0 <= _ref5 ? _k < _ref5 : _k > _ref5; k = 0 <= _ref5 ? ++_k : --_k) {
                          if (this._vectors[j].vectors[k].setStyle) {
                            this._vectors[j].vectors[k].setStyle(this._getFeatureVectorOptions(this._vectors[j]));
                          } else {
                            if (this._vectors[j].vectors[k].setIcon) {
                              this._vectors[j].vectors[k].setIcon(this._getFeatureVectorOptions(this._vectors[j]).icon);
                            }
                          }
                        }
                      } else if (this._vectors[j].vector) {
                        if (this._vectors[j].vector.setStyle) {
                          this._vectors[j].vector.setStyle(this._getFeatureVectorOptions(this._vectors[j]));
                        } else {
                          if (this._vectors[j].vector.setIcon) {
                            this._vectors[j].vector.setIcon(this._getFeatureVectorOptions(this._vectors[j]).icon);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (!onMap || !this.options.uniqueField) {
            geometry = data.features[i].geometry;
            geometryOptions = this._getFeatureVectorOptions(data.features[i]);
            vector_or_vectors = this._geoJsonGeometryToLeaflet(geometry, geometryOptions);
            data.features[i][(vector_or_vectors instanceof Array ? "vectors" : "vector")] = vector_or_vectors;
            if (this.options.cluster) {
              if (data.features[i].vector) {
                markers.addLayer(data.features[i].vector);
              } else if (data.features[i].vectors && data.features[i].vectors.length) {
                for (k = _l = 0, _ref6 = data.features[i].vectors.length; 0 <= _ref6 ? _l < _ref6 : _l > _ref6; k = 0 <= _ref6 ? ++_l : --_l) {
                  markers.addLayer(data.features[i].vectors[k]);
                }
              }
            } else {
              if (data.features[i].vector) {
                this.options.map.addLayer(data.features[i].vector);
              } else if (data.features[i].vectors && data.features[i].vectors.length) {
                for (k = _m = 0, _ref7 = data.features[i].vectors.length; 0 <= _ref7 ? _m < _ref7 : _m > _ref7; k = 0 <= _ref7 ? ++_m : --_m) {
                  this.options.map.addLayer(data.features[i].vectors[k]);
                }
              }
            }
            this._vectors.push(data.features[i]);
            if (this.options.popupTemplate) {
              me = this;
              feature = data.features[i];
              this._setPopupContent(feature);
              (function(feature) {
                var _n, _ref8, _results1;
                if (feature.vector) {
                  return feature.vector.on("click", function(event) {
                    return me._showPopup(feature, event);
                  });
                } else if (feature.vectors) {
                  _results1 = [];
                  for (k = _n = 0, _ref8 = feature.vectors.length; 0 <= _ref8 ? _n < _ref8 : _n > _ref8; k = 0 <= _ref8 ? ++_n : --_n) {
                    _results1.push(feature.vectors[k].on("click", function(event) {
                      return me._showPopup(feature, event);
                    }));
                  }
                  return _results1;
                }
              })(feature);
            }
            if (this.options.clickEvent) {
              me = this;
              feature = data.features[i];
              (function(feature) {
                var _n, _ref8, _results1;
                if (feature.vector) {
                  return feature.vector.on("click", function(event) {
                    return me._fireClickEvent(feature, event);
                  });
                } else if (feature.vectors) {
                  _results1 = [];
                  for (k = _n = 0, _ref8 = feature.vectors.length; 0 <= _ref8 ? _n < _ref8 : _n > _ref8; k = 0 <= _ref8 ? ++_n : --_n) {
                    _results1.push(feature.vectors[k].on("click", function(event) {
                      return me._fireClickEvent(feature, event);
                    }));
                  }
                  return _results1;
                }
              })(feature);
            }
          }
          if (this.options.cluster) {
            _results.push(this.options.map.addLayer(markers));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    }
  });

  H5.Leaflet.GeoJSONLayer = H5.Leaflet.Layer.extend({
    _geoJsonGeometryToLeaflet: function(geometry, opts) {
      var i, j, k, latlngs, latlngss, vector, vectors, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _ref10, _ref11, _ref12, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      vector = void 0;
      vectors = void 0;
      switch (geometry.type) {
        case "Point":
          if (opts.circleMarker) {
            vector = new L.CircleMarker(new L.LatLng(geometry.coordinates[1], geometry.coordinates[0]), opts);
          } else {
            vector = new L.Marker(new L.LatLng(geometry.coordinates[1], geometry.coordinates[0]), opts);
          }
          break;
        case "MultiPoint":
          vectors = [];
          for (i = _i = 0, _ref3 = geometry.coordinates.length; 0 <= _ref3 ? _i < _ref3 : _i > _ref3; i = 0 <= _ref3 ? ++_i : --_i) {
            vectors.push(new L.Marker(new L.LatLng(geometry.coordinates[i][1], geometry.coordinates[i][0]), opts));
          }
          break;
        case "LineString":
          latlngs = [];
          for (i = _j = 0, _ref4 = geometry.coordinates.length; 0 <= _ref4 ? _j < _ref4 : _j > _ref4; i = 0 <= _ref4 ? ++_j : --_j) {
            latlngs.push(new L.LatLng(geometry.coordinates[i][1], geometry.coordinates[i][0]));
          }
          vector = new L.Polyline(latlngs, opts);
          break;
        case "MultiLineString":
          vectors = [];
          for (i = _k = 0, _ref5 = geometry.coordinates.length; 0 <= _ref5 ? _k < _ref5 : _k > _ref5; i = 0 <= _ref5 ? ++_k : --_k) {
            latlngs = [];
            for (j = _l = 0, _ref6 = geometry.coordinates[i].length; 0 <= _ref6 ? _l < _ref6 : _l > _ref6; j = 0 <= _ref6 ? ++_l : --_l) {
              latlngs.push(new L.LatLng(geometry.coordinates[i][j][1], geometry.coordinates[i][j][0]));
            }
            vectors.push(new L.Polyline(latlngs, opts));
          }
          break;
        case "Polygon":
          latlngss = [];
          for (i = _m = 0, _ref7 = geometry.coordinates.length; 0 <= _ref7 ? _m < _ref7 : _m > _ref7; i = 0 <= _ref7 ? ++_m : --_m) {
            latlngs = [];
            for (j = _n = 0, _ref8 = geometry.coordinates[i].length; 0 <= _ref8 ? _n < _ref8 : _n > _ref8; j = 0 <= _ref8 ? ++_n : --_n) {
              latlngs.push(new L.LatLng(geometry.coordinates[i][j][1], geometry.coordinates[i][j][0]));
            }
            latlngss.push(latlngs);
          }
          vector = new L.Polygon(latlngss, opts);
          break;
        case "MultiPolygon":
          vectors = [];
          for (i = _o = 0, _ref9 = geometry.coordinates.length; 0 <= _ref9 ? _o < _ref9 : _o > _ref9; i = 0 <= _ref9 ? ++_o : --_o) {
            latlngss = [];
            for (j = _p = 0, _ref10 = geometry.coordinates[i].length; 0 <= _ref10 ? _p < _ref10 : _p > _ref10; j = 0 <= _ref10 ? ++_p : --_p) {
              latlngs = [];
              for (k = _q = 0, _ref11 = geometry.coordinates[i][j].length; 0 <= _ref11 ? _q < _ref11 : _q > _ref11; k = 0 <= _ref11 ? ++_q : --_q) {
                latlngs.push(new L.LatLng(geometry.coordinates[i][j][k][1], geometry.coordinates[i][j][k][0]));
              }
              latlngss.push(latlngs);
            }
            vectors.push(new L.Polygon(latlngss, opts));
          }
          break;
        case "GeometryCollection":
          vectors = [];
          for (i = _r = 0, _ref12 = geometry.coordinates.length; 0 <= _ref12 ? _r < _ref12 : _r > _ref12; i = 0 <= _ref12 ? ++_r : --_r) {
            vectors.push(this._geoJsonGeometryToLeaflet(geometry.geometries[i], opts));
          }
      }
      return vector || vectors;
    }
  });

  H5.Leaflet.Postgis = H5.Leaflet.GeoJSONLayer.extend({
    initialize: function(options) {
      var i, sr, z, _i, _ref3;
      for (i = _i = 0, _ref3 = this._requiredParams.length; 0 <= _ref3 ? _i < _ref3 : _i > _ref3; i = 0 <= _ref3 ? ++_i : --_i) {
        if (!options[this._requiredParams[i]]) {
          throw new Error("No \"" + this._requiredParams[i] + "\" parameter found.");
        }
      }
      if (options.url.substr(options.url.length - 1, 1) !== "/") {
        options.url += "/";
      }
      H5.Leaflet.Layer.prototype.initialize.call(this, options);
      this._globalPointer = "PRWSF_" + Math.floor(Math.random() * 100000);
      window[this._globalPointer] = this;
      this._vectors = [];
      if (this.options.map) {
        if (this.options.scaleRange && this.options.scaleRange instanceof Array && this.options.scaleRange.length === 2) {
          z = this.options.map.getZoom();
          sr = this.options.scaleRange;
          this.options.visibleAtScale = z >= sr[0] && z <= sr[1];
        }
        return this._show();
      }
    },
    options: {
      geotable: null,
      srid: null,
      geomFieldName: "the_geom",
      fields: null,
      where: null,
      limit: 1000,
      uniqueField: null
    },
    _requiredParams: ["url", "geotable"],
    _getFeatures: function() {
      var bounds, fields, ne, sw, url, where;
      where = (this.options.where ? "&parameters=" + encodeURIComponent(this.options.where) : null);
      if (!this.options.showAll) {
        bounds = this.options.map.getBounds();
        sw = bounds.getSouthWest();
        ne = bounds.getNorthEast();
        where += (where.length ? " AND " : "");
        if (this.options.srid) {
          where += this.options.geomFieldName + " && st_setsrid(st_makebox2d(st_point(" + sw.lng + "," + sw.lat + "),st_point(" + ne.lng + "," + ne.lat + "))," + this.options.srid + ")";
        } else {
          where += "" + this.options.geomFieldName + ",4326) && st_setsrid(st_makebox2d(st_point(" + sw.lng + "," + sw.lat + "),st_point(" + ne.lng + "," + ne.lat + "))";
        }
      }
      fields = (this.options.fields ? this.options.fields : "*") + ", st_asgeojson(" + this.options.geomFieldName + "" + (this.options.geomPrecision ? "," + this.options.geomPrecision : "") + ") as geojson";
      url = this.options.url + "v1/ws_geo_attributequery.php" + "?table=" + this.options.geotable + "&fields=" + encodeURIComponent(fields) + where + "&limit=" + this.options.limit + "&callback=" + this._globalPointer + "._processRequest";
      return this._makeJsonpRequest(url);
    }
  });

  H5.Leaflet.RapidEyeTMS = (function() {
    RapidEyeTMS.prototype.options = {
      url: null,
      table: null,
      numberOfLayers: 4
    };

    function RapidEyeTMS(options) {
      this.listLayers = [];
      this.layers = {};
      this.layerGroup = [];
      this.count = 1;
      L.setOptions(this, options);
      this._createTMSLayers();
      this._loadGeoJSON();
      this._addToLayerControl();
    }

    RapidEyeTMS.prototype._onEachFeature = function(feature, layer) {
      var popupContent;
      popupContent = "<p>I started out as a GeoJSON " + feature.geometry.type + ", but now I'm a Leaflet vector!</p>";
      if (feature.properties && feature.properties.popupContent) {
        popupContent += feature.properties.popupContent;
      }
      layer.bindPopup(popupContent);
      layer.on("mouseover click", function(e) {
        var tmsUrl;
        tmsUrl = feature.properties.url_tiles + "{z}/{x}/{y}.png";
        layer.setStyle({
          fillColor: "transparent",
          stroke: false
        });
        if (this._checkLayer(layer._leaflet_id)) {
          this.layers[this.count].setUrl(tmsUrl);
          this.layers[this.count].redraw();
          this.listLayers.push(layer._leaflet_id);
          if (this.listLayers.length > this.options.numberOfLayers) {
            this.listLayers.shift();
          }
          this.count++;
          if (this.count > this.options.numberOfLayers) {
            return this.count = 1;
          }
        }
      });
      return layer.on("mouseout", function(e) {
        return layer.setStyle({
          stroke: true
        });
      });
    };

    RapidEyeTMS.prototype._createTMSLayers = function() {
      var i, _results;
      i = 1;
      _results = [];
      while (i <= this.options.numberOfLayers) {
        this.layers[i] = new L.TileLayer("", {
          minZoom: 3,
          maxZoom: 17,
          tms: true
        });
        this.layerGroup.push(this.layers[i]);
        _results.push(i++);
      }
      return _results;
    };

    RapidEyeTMS.prototype._checkLayer = function(layerId) {
      var i, _i, _ref3;
      for (i = _i = 0, _ref3 = this.listLayers.length; 0 <= _ref3 ? _i < _ref3 : _i > _ref3; i = 0 <= _ref3 ? ++_i : --_i) {
        if (layerId === this.listLayers[i]) {
          return false;
        }
      }
      return true;
    };

    RapidEyeTMS.prototype._loadGeoJSON = function() {
      var rest;
      rest = new H5.PgRest({
        url: this.options.url,
        table: this.options.table
      });
      return this._vectors = L.geoJson(rest.request(), {
        style: {
          fillColor: "transparent",
          color: "purple",
          weight: 4
        },
        onEachFeature: this._onEachFeature
      });
    };

    RapidEyeTMS.prototype._addToLayerControl = function() {
      var rapidEyeLayer;
      rapidEyeLayer = new L.LayerGroup(this.layerGroup);
      rapidEyeLayer.addLayer(this._vectors);
      if (H5.Map.layerList) {
        return H5.Map.layerList.addLayer(rapidEyeLayer, "RapidEye");
      }
    };

    return RapidEyeTMS;

  })();

  H5.Leaflet.LayerControl = L.Control.extend({
    options: {
      collapsed: true,
      position: "topright",
      autoZIndex: true
    },
    initialize: function(baseLayers, options) {
      var i, _results;
      L.setOptions(this, options);
      this._layers = {};
      this._lastZIndex = 0;
      this._handlingClick = false;
      _results = [];
      for (i in baseLayers) {
        _results.push(this._addLayer(baseLayers[i], i));
      }
      return _results;
    },
    onAdd: function(map) {
      this._initLayout();
      this._update();
      map.on("layeradd", this._onLayerChange, this).on("layerremove", this._onLayerChange, this);
      return this._container;
    },
    onRemove: function(map) {
      return map.off("layeradd", this._onLayerChange).off("layerremove", this._onLayerChange);
    },
    addLayer: function(layer, name) {
      this._addLayer(layer, name);
      this._update();
      return this;
    },
    removeLayer: function(layer) {
      var id;
      id = L.stamp(layer);
      delete this._layers[id];
      this._update();
      return this;
    },
    _initLayout: function() {
      var className, container, form, link;
      className = "leaflet-control-layers";
      container = this._container = L.DomUtil.create("div", className);
      if (!L.Browser.touch) {
        L.DomEvent.disableClickPropagation(container);
        L.DomEvent.on(container, "mousewheel", L.DomEvent.stopPropagation);
      } else {
        L.DomEvent.on(container, "click", L.DomEvent.stopPropagation);
      }
      form = this._form = L.DomUtil.create("form", className + "-list form-layer-list");
      if (this.options.collapsed) {
        L.DomEvent.on(container, "mouseover", this._expand, this).on(container, "mouseout", this._collapse, this);
        link = this._layersLink = L.DomUtil.create("a", className + "-toggle", container);
        link.href = "#";
        link.title = "Layers";
        if (L.Browser.touch) {
          L.DomEvent.on(link, "click", L.DomEvent.stopPropagation).on(link, "click", L.DomEvent.preventDefault).on(link, "click", this._expand, this);
        } else {
          L.DomEvent.on(link, "focus", this._expand, this);
        }
        this._map.on("movestart", this._collapse, this);
      } else {
        this._expand();
      }
      this._baseLayersList = L.DomUtil.create("div", className + "-base", form);
      return container.appendChild(form);
    },
    _addLayer: function(layer, name) {
      var id;
      id = L.stamp(layer);
      this._layers[id] = {
        layer: layer,
        name: name
      };
      if (this.options.autoZIndex && layer.setZIndex) {
        this._lastZIndex++;
        return layer.setZIndex(this._lastZIndex);
      }
    },
    _update: function() {
      var i, obj, _results;
      if (!this._container) {
        return;
      }
      this._baseLayersList.innerHTML = "";
      i = void 0;
      obj = void 0;
      _results = [];
      for (i in this._layers) {
        obj = this._layers[i];
        _results.push(this._addItem(obj));
      }
      return _results;
    },
    _onLayerChange: function(e) {
      var id;
      id = L.stamp(e.layer);
      if (this._layers[id] && !this._handlingClick) {
        return this._update();
      }
    },
    _addItem: function(obj) {
      var checked, container, control, controlgroup, input, label, toggle, _this;
      _this = this;
      container = this._baseLayersList;
      controlgroup = L.DomUtil.create("div", "control-group", container);
      checked = this._map.hasLayer(obj.layer);
      label = L.DomUtil.create("label", "control-label pull-left", controlgroup);
      label.innerHTML = " " + obj.name;
      control = L.DomUtil.create("div", "control pull-right", controlgroup);
      toggle = L.DomUtil.create("div", "switch switch-small", control);
      input = L.DomUtil.create("input", "leaflet-control-layers-selector", toggle);
      input.type = "checkbox";
      input.defaultChecked = checked;
      input.layerId = L.stamp(obj.layer);
      $(toggle).on("switch-change", function(e, data) {
        return _this._onInputClick(input, obj);
      });
      return controlgroup;
    },
    _onInputClick: function(input, obj) {
      this._handlingClick = true;
      if (input.checked) {
        this._map.addLayer(obj.layer);
        this._map.fire("layeradd", {
          layer: obj
        });
      } else {
        this._map.removeLayer(obj.layer);
        this._map.fire("layerremove", {
          layer: obj
        });
      }
      return this._handlingClick = false;
    },
    _expand: function() {
      return L.DomUtil.addClass(this._container, "leaflet-control-layers-expanded");
    },
    _collapse: function() {
      return this._container.className = this._container.className.replace(" leaflet-control-layers-expanded", "");
    }
  });

}).call(this);
